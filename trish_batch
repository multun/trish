#!/usr/bin/env python3

import sys

from pathlib import PosixPath
from itertools import combinations, chain
from libtrish.par import par_list_map
from libtrish.conf import load_conf

try:
    from tqdm import tqdm as progress
except:
    progress = lambda x: x


def get_dir_lines(dir_path, glob):
    for file_path in filter(lambda x: x.is_file(), dir_path.glob(glob)):
        try:
            with file_path.open() as fp:
                yield from fp.readlines()
        except:
            continue


def get_dir_meta(conf, *args, **kwargs):
    return conf.compute_meta(get_dir_lines(*args, **kwargs))


def pair_process(conf, pair):
    chal = conf.Challenge(*chain(*pair))
    conf.exporter(chal, conf.evaluate_chal(chal))
    sys.stdout.flush()


def batch_compare(conf, path, glob, proc):
    subdirs = list(filter(lambda e: e.is_dir(), path.iterdir()))
    codebases = list(map(lambda sdir: get_dir_meta(conf, sdir, glob), subdirs))
    metas = list(zip(codebases, map(lambda e: e.name, subdirs)))
    pair_list = list(combinations(metas, 2))
    pair_count = len(pair_list) # len(metas) ** 2 // 2 - len(metas) // 2

    def wproc(e):
        pair_process(conf, e)

    if proc < 2:
        for e in progress(pair_list):
            wproc(e)
    else:
        par_list_map(wproc, pair_list, pair_count, proc)


if __name__ == '__main__':
    if len(sys.argv) not in (3, 4):
        print(f"Usage: {sys.argv[0]} FOLDER FILE_GLOB [PROC_COUNT]")
        exit(1)

    proc = int(sys.argv[3]) if len(sys.argv) > 3 else 1
    conf = load_conf()
    batch_compare(conf(), PosixPath(sys.argv[1]), sys.argv[2], proc)
